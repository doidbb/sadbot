#!/usr/bin/env bash

run=true

helpp() {
    echo " "
    echo "» SADBOT -configuration for networks + channels found in sadbot/config"
    echo "» modues found in sadbot/modules - called by filename, output in to channel whatever the file prints"
}

verbose=false
hlp=false
case $@ in
	-v) verbose=true;;
	--verbose) verbose=true;;
	-h) hlp=true;;
	--help) hlp=true;;
esac

init() {
    ghost=true
    if $hlp ; then 
        helpp
    fi
    source ./config
    source ./irc
    echo " "
    echo "» Sadbot - Spectrum Andri Andy Droid BOT"
    echo "» Jonnecting to $NETWORK with nick \`$NICK\`"
    for chan in ${CHANNEL[@]}; do
	    echo "» Joining $chan"
    done
}

conn() {
    exec 3<>/dev/tcp/${NETWORK}/${PORT}; #connects to irc network
    echo "USER ${IDENT} 0 1 :$IRCNAME " >&3;
    echo "NICK ${NICK}" >&3;
}

parse() {
    IFS=$'\r\n' MODULES=($(for file in ./modules/*; do echo ${file##*/}; done))
    for mod in ${MODULES[@]}; do                                    #loads modules
        IFS=':' read -r raw cut <<< "$msg_in"                       #cuts raw message to first : (first character)
        IFS=':' read -r raw cut <<< "$cut"                          #cuts again to second : (start of the actual message)
        first_word=${cut%% *}                                       #obtains the first word of the message e.g (:raw     ::trikt   ==>  :raw)
        if [[ "$first_word" = ":$mod" ]]; then                      #checks if the first word of the message is equal to any of the modules in the array
            delim="::$mod"                                          #searches for input with a prefix command
            arg=$(echo $msg_in | awk -F $delim '{print $NF}')       #strips the input down to just the argument
            get_chan $msg_in                #obtain the channel of origin and the sender
	        get_nick $msg_in
            handle
        fi
    done
    if [[ $msg_in =~ " PRIVMSG " && ! $msg_in =~ ":py-ctcp" ]]; then    #only respond to triggers if detecting a PRIVMSG and not from py-ctcp

    IFS=$'\r\n' TRIGGERS=($(for file in ./triggers/*; do echo ${file##*/}; done))
    for trig in ${TRIGGERS[@]}; do
        get_chan $msg_in
        get_nick $msg_in
        if [[ $nickchan = $NICK ]]; then    #checks if private message is being recieved
            chan=$channick                  #if so, sets the output directly back to the sender
        else
            chan=$nickchan                  #otherwise set the output as the channel of origin
        fi
        
        IFS=':' read -r raw cut <<< "$msg_in"                       #cuts raw message to first : (first character)
        IFS=':' read -r raw arg <<< "$cut"                       #cuts raw message to first : (first character)
        
        if [[ $(./triggers/$trig "$channick" "$arg" "$msg_in") ]]; then                   #checks if script will actually output before sending
            output=$(./triggers/$trig "$channick" "$arg" "$msg_in")                       #raw output from module
            strip=$(echo $output | awk -F ']' '{print $NF}')   #removes prefixes
                 
            if [[ $output =~ "[me]" ]]; then      #searches for prefixes in input and chooses
                msg_act $chan $strip                 #appropriate output function
            elif [[ $output =~ "[msg]" ]]; then
                msg_out $chan $strip
            elif [[ $output =~ "[rb]" ]]; then
                msg_rbc $chan $strip 
            elif [[ $output =~ "[k]" ]]; then
                if [[ $strip =~ "sadbot" ]]; then
                    msg_out $chan "nice try"
                else
                    kick $chan $strip
                fi
            else 
                 msg_out $chan $(./triggers/$trig "$channick" "$arg" "$msg_in")             #sends arguments to trigger 1 = nick of sender 2 = parsed input 3 = raw input
            fi
        fi
    done
fi

}

log() {
    folderchan=$(echo $nickchan | sed 's/\//-/g')
    IFS=':' read -r raw cut <<< "$msg_in"                       #cuts raw message to first : (first character)
    IFS=':' read -r raw message <<< "$cut"                       #cuts raw message to first : (first character)
   
    if [[ -f ./logs/$folderchan ]] ; then
        echo $(date +nc +"%d/%m/%Y %H:%M:%S" | sed 's/[A-Za-z]ST 201[0-9]//g'): "<$channick> ${message}" >> ./logs/$folderchan
    else
        touch ./logs/$folderchan
        echo $(date +nc +"%d/%m/%Y %H:%M:%S" | sed 's/[A-Za-z]ST 201[0-9]//g'): "<$channick> ${message}" >> ./logs/$folderchan
    fi
    cat ./logs/$folderchan | sed -i 's/ACTION/*/' ./logs/$folderchan
}

handle() {
    if [[ $nickchan = $NICK ]]; then    #checks if private message is being recieved
        chan=$channick                  #if so, sets the output directly back to the sender
    else
        chan=$nickchan                  #otherwise set the output as the channel of origin
    fi
    output=$(./modules/$mod $channick $arg $msg_in)                       #raw output from module
    strip=$(echo $output | awk -F ']' '{print $NF}')   #removes prefixes
    
    if [[ $output =~ "[me]" ]]; then      #searches for prefixes in input and chooses
        msg_act $chan $strip                 #appropriate output function
    elif [[ $output =~ "[msg]" ]]; then
        msg_out $chan $strip
    elif [[ $output =~ "[rb]" ]]; then
        msg_rbc $chan $strip
    elif [[ $output =~ "[k]" ]]; then
        if [[ $strip =~ "sadbot" ]]; then
            msg_out $chan "nice try"
        else
            kick $chan $strip
        fi
    else 
        msg_out $chan $(./modules/$mod "$channick" "$arg" "$msg_in")    #sends arguments to module 
    fi
}

main() {
    while [ true ]; do
	read msg_in <&3;
        if $verbose ; then
	    echo $msg_in
	fi
    parse
    ping
    ghost 		#will ghost but doesn't join channels
    for chan in ${CHANNEL[@]}; do
        if [[ $msg_in =~ "PRIVMSG $chan" ]]; then
            log
        fi
    done
    if $run ; then	#really hacky please fix me
	    if $ghost ; then
	        join
            echo "» Joining Channels"
	        ident
        fi
        run=false
    fi
    done
}

init && conn && main;
